#!/usr/bin/python

"""PowerGSLB

PowerDNS Remote GSLB Backend
"""

import abc
import argparse
import ast
import BaseHTTPServer
import ConfigParser
import json
import logging
import os
import socket
import SocketServer
import threading
import time
import urllib2

import mysql.connector
import netaddr
import pyping
import subprocess32
import systemd.daemon


__author__ = 'Aleksey Chudov <aleksey.chudov@gmail.com>'
__date__ = '23 Jan 2016'
__version__ = '1.2.0'


class AbstractThread(threading.Thread):

    __metaclass__ = abc.ABCMeta

    def __init__(self, **kwargs):
        super(AbstractThread, self).__init__(**kwargs)
        self.__shutdown_event = threading.Event()
        self.__shutdown_request = False
        self.daemon = True
        self.sleep_interval = 0

    def run(self):
        logging.debug('{} thread started'.format(self.name))
        try:
            while not self.__shutdown_request:
                self.task()
                time.sleep(self.sleep_interval)
        finally:
            logging.debug('{} thread stopped'.format(self.name))
            self.__shutdown_event.set()

    def shutdown(self, timeout=0):
        logging.debug('{} thread shutdown'.format(self.name))
        self.__shutdown_request = True
        self.__shutdown_event.wait(timeout)

    @abc.abstractmethod
    def task(self):
        pass


class Check(AbstractThread):

    def __init__(self, monitor, record_id, **kwargs):
        super(Check, self).__init__(**kwargs)
        self.monitor = monitor
        self.record_id = record_id
        self.sleep_interval = self.monitor['interval']
        self.fall = 0
        self.rise = 0

    def check_fall(self):
        self.fall += 1
        self.rise = 0

        if self.fall >= self.monitor['fall'] and self.record_id not in Monitor.status:
            logging.error('{}: {}: status fall'.format(self.name, self.monitor))
            Monitor.status.add(self.record_id)

    def check_rise(self):
        self.fall = 0
        self.rise += 1

        if self.rise >= self.monitor['rise'] and self.record_id in Monitor.status:
            logging.info('{}: {}: status rise'.format(self.name, self.monitor))
            Monitor.status.remove(self.record_id)

    def do_exec(self):
        return subprocess32.call(self.monitor['args'], timeout=self.monitor['timeout']) == 0

    def do_http(self):
        urllib2.urlopen(self.monitor['url'], timeout=self.monitor['timeout']).close()
        return True

    def do_icmp(self):
        try:
            return pyping.ping(self.monitor['ip'], timeout=self.monitor['timeout'] * 1000, count=1).ret_code == 0
        except SystemExit:
            raise PingError('unknown host: {}'.format(self.monitor['ip']))

    def do_tcp(self):
        socket.create_connection((self.monitor['ip'], self.monitor['port']), self.monitor['timeout']).close()
        return True

    def task(self):
        try:
            if getattr(self, 'do_' + self.monitor['type'])():
                logging.debug('{}: {}: return True'.format(self.name, self.monitor))
                self.check_rise()
            else:
                logging.debug('{}: {}: return False'.format(self.name, self.monitor))
                self.check_fall()
        except Exception as e:
            logging.debug('{}: {}: return Exception: {}: {}'.format(self.name, self.monitor, type(e).__name__, e))
            self.check_fall()


class Database(mysql.connector.MySQLConnection):

    Error = mysql.connector.Error

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.disconnect()

    def __init__(self):
        super(Database, self).__init__(**dict(PowerGSLB.config.items('mysql')))

    def execute(self, query, params=()):
        if params:
            logging.debug('{}: "{}" % {}'.format(type(self).__name__, query, params))
        else:
            logging.debug('{}: "{}"'.format(type(self).__name__, query))

        cursor = self.cursor()
        cursor.execute(query, params)

        column_names = [description[0] for description in cursor.description]
        result = [dict(zip(column_names, row)) for row in cursor]
        cursor.close()

        return result

    def get_checks(self):
        query = ("SELECT id, name, type, content, ttl, monitor "
                 "FROM records WHERE monitor IS NOT NULL AND disabled = 0")

        return self.execute(query)

    def get_records(self, qname, qtype):
        if qtype == 'ANY':
            query = ("SELECT id, name AS qname, type AS qtype, content, ttl, fallback, persistence, weight "
                     "FROM records WHERE name = %s AND disabled = 0")
            params = (qname,)
        else:
            query = ("SELECT id, name AS qname, type AS qtype, content, ttl, fallback, persistence, weight "
                     "FROM records WHERE name = %s AND type = %s AND disabled = 0")
            params = (qname, qtype)

        return self.execute(query, params)

    def get_status(self, record_ids):
        joined_ids = ', '.join(map(str, record_ids))
        query = "SELECT name, type, content, ttl FROM records WHERE id IN ({})".format(joined_ids)

        return self.execute(query)


class HTTPRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler, object):

    close_connection = 0
    protocol_version = 'HTTP/1.1'
    server_version = 'PowerGSLB/' + __version__
    rbufsize = -1
    wbufsize = -1

    def __init__(self, *args):
        self.database = None
        self.ipv4_prefix = PowerGSLB.config.get('persistence', 'ipv4_prefix')
        self.ipv6_prefix = PowerGSLB.config.get('persistence', 'ipv6_prefix')
        super(HTTPRequestHandler, self).__init__(*args)

    def do_GET(self):
        query = self.path.split('/')
        if len(query) == 5 and query[1] == 'dns':
            self.send_response(200)
            content = self.get_result(*query[2:])
            self.send_header('Content-Type', 'text/javascript; charset=utf-8')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
            logging.debug('{}: {}'.format(type(self).__name__, content))
        elif len(query) == 2 and query[1] == 'status':
            self.send_response(200)
            content = self.get_status()
            self.send_header('Content-Type', 'text/javascript; charset=utf-8')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
        else:
            self.send_error(404)

    def filter_records(self, qtype_records):
        records = []
        for qtype in qtype_records:

            fallback_max_weight = 0
            fallback_records = []
            live_max_weight = 0
            live_records = []

            for record in qtype_records[qtype]:
                if record['fallback']:
                    fallback_records.append(record)
                    if record['weight'] > fallback_max_weight:
                        fallback_max_weight = record['weight']

                if record['id'] not in Monitor.status:
                    live_records.append(record)
                    if record['weight'] > live_max_weight:
                        live_max_weight = record['weight']

            persistence = True
            filtered_records = []

            if live_records:
                for record in live_records:
                    if record['weight'] == live_max_weight:
                        filtered_records.append(record)
                        if persistence and not record['persistence']:
                            persistence = False
            else:
                for record in fallback_records:
                    if record['weight'] == fallback_max_weight:
                        filtered_records.append(record)
                        if persistence and not record['persistence']:
                            persistence = False

            if not filtered_records:
                continue

            if persistence:
                records.append(self.remote_ip_persistence(filtered_records))
            else:
                records.extend(filtered_records)

        return records

    def get_result(self, method, qname, qtype):
        result = False
        if method == 'lookup':
            try:
                records = self.database.get_records(qname, qtype)
            except Database.Error as e:
                logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
                self.close_connection = 1
            else:
                if records:
                    qtype_records = self.split_records(records)
                    filtered_records = self.filter_records(qtype_records)
                    result = self.strip_records(filtered_records)

        return json.dumps({'result': result}, separators=(',', ':'))

    def get_status(self):
        status = True
        failed_ids = Monitor.status.copy()

        if failed_ids:
            try:
                status = self.database.get_status(failed_ids)
            except Database.Error as e:
                logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
                self.close_connection = 1
                status = False

        return json.dumps({'status': status}, separators=(',', ':'))

    def handle(self):
        try:
            with Database() as self.database:
                while not self.close_connection:
                    self.handle_one_request()
        except Database.Error as e:
            logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))

    def remote_ip_persistence(self, records):
        ip_value = 0
        try:
            remote_ip = self.headers.get('X-Remotebackend-Real-Remote')
            if remote_ip:
                network = netaddr.IPNetwork(remote_ip)
                if network.version == 4:
                    first_ip = netaddr.IPNetwork('{}/{}'.format(network.ip, self.ipv4_prefix)).first
                    ip_value = first_ip >> self.ipv4_prefix
                elif network.version == 6:
                    first_ip = netaddr.IPNetwork('{}/{}'.format(network.ip, self.ipv6_prefix)).first
                    ip_value = first_ip >> self.ipv6_prefix
        except netaddr.AddrFormatError as e:
            logging.error('{}: remote ip persistence error: {}: {}'.format(
                    type(self).__name__, type(e).__name__, e))

        return records[hash(ip_value) % len(records)]

    def split_records(self, records):
        qtype_records = {}
        for record in records:
            if record['qtype'] in ['MX', 'SRV']:
                content_split = record['content'].split()
                try:
                    record['priority'] = int(content_split[0])
                    record['content'] = ' '.join(content_split[1:])
                except (KeyError, ValueError) as e:
                    logging.error('{}: record id {} priority missing or invalid: {}: {}'.format(
                            type(self).__name__, record['id'], type(e).__name__, e))
                    continue

            if record['qtype'] not in qtype_records:
                qtype_records[record['qtype']] = []

            qtype_records[record['qtype']].append(record)

        return qtype_records

    @staticmethod
    def strip_records(records):
        result = []
        for record in records:
            if record['qtype'] in ['MX', 'SRV']:
                names = ['qname', 'qtype', 'content', 'ttl', 'priority']
                values = [record['qname'], record['qtype'], record['content'], record['ttl'], record['priority']]
            else:
                names = ['qname', 'qtype', 'content', 'ttl']
                values = [record['qname'], record['qtype'], record['content'], record['ttl']]

            result.append(dict(zip(names, values)))

        return result


class LockSet(set):

    def __init__(self, seq=()):
        super(LockSet, self).__init__(seq)
        self.__lock = threading.RLock()

    def add(self, elem):
        with self.__lock:
            return super(LockSet, self).add(elem)

    def remove(self, elem):
        with self.__lock:
            return super(LockSet, self).add(elem)


class Monitor(AbstractThread):

    check_params = {
        'exec': [('args', list), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'icmp': [('ip', str), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'http': [('url', str), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'tcp': [('ip', str), ('port', int), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)]
    }

    status = LockSet()

    def __init__(self, **kwargs):
        super(Monitor, self).__init__(**kwargs)
        self.check_threads = []
        self.checks = []
        self.refresh_threads = False
        self.sleep_interval = PowerGSLB.config.get('monitor', 'update_interval')

    def clean_status(self):
        check_ids = set([check['id'] for check in self.checks])
        stale_ids = Monitor.status.difference(check_ids)

        if stale_ids:
            logging.debug('{}: clean status for records: {}'.format(
                    type(self).__name__, ', '.join(map(str, stale_ids))))
            Monitor.status.intersection_update(check_ids)

    def parse(self, check):
        parse_status = False
        try:
            check['monitor'] = dict(ast.literal_eval(check['monitor'] % check))
            parse_status = True
        except (SyntaxError, ValueError) as e:
            logging.error('{}: record id {}: check parsing error: {}: {}'.format(
                    type(self).__name__, check['id'], type(e).__name__, e))

        return parse_status

    def shutdown_check_threads(self):
        if not self.check_threads:
            logging.info('{}: check threads are not running'.format(type(self).__name__))
            return

        logging.debug('{}: shutdown threads: {}'.format(type(self).__name__, self.check_threads))

        alive_threads = []
        shutdown_timeout = 0

        for check_thread in self.check_threads:
            if check_thread.is_alive():
                check_thread.shutdown()
                alive_threads.append(check_thread)
                if check_thread.sleep_interval > shutdown_timeout:
                    shutdown_timeout = check_thread.sleep_interval

        shutdown_time = time.time()
        shutdown_timeout *= 2

        while alive_threads and time.time() - shutdown_time < shutdown_timeout:
            time.sleep(1)
            alive_threads = [alive_thread for alive_thread in alive_threads if alive_thread.is_alive()]

        self.check_threads = alive_threads

    def start_check_threads(self):
        if self.check_threads:
            logging.error('{}: check threads already running: {}'.format(type(self).__name__, self.check_threads))
            return

        check_threads = []
        for check in self.checks:
            check_thread = Check(check['monitor'], check['id'], name='Check-{}'.format(check['id']))
            check_thread.start()
            check_threads.append(check_thread)

        logging.debug('{}: started threads: {}'.format(type(self).__name__, check_threads))

        self.check_threads = check_threads

    def task(self):
        self.update_checks()
        self.verify_check_threads()
        if self.refresh_threads:
            self.shutdown_check_threads()
            self.clean_status()
            self.start_check_threads()

    def update_checks(self):
        logging.info('{}: update checks from the database'.format(type(self).__name__))
        refresh_threads = False
        try:
            with Database() as database:
                raw_checks = database.get_checks()
        except Database.Error as e:
            logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
        else:
            checks = [check for check in raw_checks if self.parse(check) and self.validate(check)]
            if self.checks != checks:
                logging.debug('{}: checks updated: {}'.format(type(self).__name__, checks))
                self.checks = checks
                refresh_threads = True

        self.refresh_threads = refresh_threads

    def validate(self, check):
        validate_status = False
        try:
            for param in self.check_params[check['monitor']['type']]:
                if type(check['monitor'][param[0]]) != param[1]:
                    logging.error("{}: record id {}: check parameter '{}' invalid".format(
                            type(self).__name__, check['id'], param[0]))
        except KeyError as e:
            logging.error("{}: record id {}: check parameter '{}' missing".format(
                    type(self).__name__, check['id'], e.message))
        else:
            if check['monitor']['timeout'] > check['monitor']['interval']:
                logging.warning("{}: record id {}: check 'timeout' is greater than 'interval': fixed".format(
                        type(self).__name__, check['id']))
                check['monitor']['timeout'] = check['monitor']['interval']

            validate_status = True

        return validate_status

    def verify_check_threads(self):
        if self.refresh_threads:
            return

        check_ids = set(check['id'] for check in self.checks)
        check_thread_ids = set(thread.record_id for thread in self.check_threads if thread.is_alive())

        if check_ids != check_thread_ids:
            running_thread_ids = check_thread_ids.difference(check_ids)
            stopped_thread_ids = check_ids.difference(check_thread_ids)

            if running_thread_ids:
                logging.error('{}: unexpectedly running threads: {}'.format(
                        type(self).__name__, ', '.join(map('Check-{}'.format, running_thread_ids))))

            if stopped_thread_ids:
                logging.error('{}: unexpectedly stopped threads: {}'.format(
                        type(self).__name__, ', '.join(map('Check-{}'.format, stopped_thread_ids))))

            self.refresh_threads = True


class PingError(Exception):
    pass


class Server(AbstractThread):

    def task(self):
        server_address = (PowerGSLB.config.get('server', 'address'), PowerGSLB.config.get('server', 'port'))
        logging.info('{}: listening on {}:{}'.format(type(self).__name__, server_address[0], server_address[1]))
        http_server = ThreadingHTTPServer(server_address, HTTPRequestHandler)
        http_server.serve_forever()


class Service(object):

    def __init__(self, service_threads):
        self.service_threads = service_threads
        self.sleep_interval = self.watchdog_interval()

    def start(self):
        [service_thread.start() for service_thread in self.service_threads]

        if systemd.daemon.booted():
            systemd.daemon.notify('READY=1')

        while all([service_thread.is_alive() for service_thread in self.service_threads]):
            if systemd.daemon.booted():
                systemd.daemon.notify('STATUS=Total threads: {}; Service threads: {}\nWATCHDOG=1'.format(
                        threading.active_count(), len(self.service_threads)))
            time.sleep(self.sleep_interval)

    @staticmethod
    def watchdog_interval(interval=1):
        if 'WATCHDOG_USEC' in os.environ:
            interval = min(interval, int(os.environ['WATCHDOG_USEC']) / 1000000 / 2)
        return interval


class SmartConfigParser(ConfigParser.RawConfigParser, object):

    def __init__(self, filenames, **kwargs):
        super(SmartConfigParser, self).__init__(**kwargs)
        self.read(filenames)

    def get(self, section, option):
        value = super(SmartConfigParser, self).get(section, option)
        try:
            value = ast.literal_eval(value)
        except (SyntaxError, ValueError):
            pass

        return value

    def items(self, section):
        smart_items = []
        for key, value in super(SmartConfigParser, self).items(section):
            try:
                value = ast.literal_eval(value)
            except (SyntaxError, ValueError):
                pass

            smart_items.append((key, value))

        return smart_items


class ThreadingHTTPServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass


class PowerGSLB(object):

    config = None

    @classmethod
    def main(cls):
        args_parser = argparse.ArgumentParser()
        args_parser.add_argument('-c', '--config', default='powergslb.conf')
        args = args_parser.parse_args()

        cls.config = SmartConfigParser(args.config)

        logging.basicConfig(format=cls.config.get('logging', 'format'),
                            level=logging.getLevelName(cls.config.get('logging', 'level')))

        service_threads = [Monitor(name='Monitor'), Server(name='Server')]
        service = Service(service_threads)
        service.start()


if __name__ == '__main__':
    PowerGSLB.main()
