#!/usr/bin/python

"""PowerGSLB

PowerDNS Remote GSLB Backend https://github.com/AlekseyChudov/powergslb
"""

import abc
import argparse
import ast
import BaseHTTPServer
import ConfigParser
import json
import logging
import os
import SimpleHTTPServer
import socket
import SocketServer
import threading
import time
import urllib2

import mysql.connector
import netaddr
import pyping
import subprocess32
import systemd.daemon


__author__ = 'Aleksey Chudov <aleksey.chudov@gmail.com>'
__date__ = '31 Jan 2016'
__version__ = '1.3.0'


class AbstractThread(threading.Thread):

    __metaclass__ = abc.ABCMeta

    def __init__(self, **kwargs):
        super(AbstractThread, self).__init__(**kwargs)
        self.__shutdown_event = threading.Event()
        self.__shutdown_request = False
        self.daemon = True
        self.sleep_interval = 0

    def run(self):
        logging.debug('{} thread started'.format(self.name))
        try:
            while not self.__shutdown_request:
                self.task()
                time.sleep(self.sleep_interval)
        finally:
            logging.debug('{} thread stopped'.format(self.name))
            self.__shutdown_event.set()

    def shutdown(self, timeout=0):
        logging.debug('{} thread shutdown'.format(self.name))
        self.__shutdown_request = True
        self.__shutdown_event.wait(timeout)

    @abc.abstractmethod
    def task(self):
        pass


class CheckThread(AbstractThread):

    def __init__(self, monitor, content_id, **kwargs):
        super(CheckThread, self).__init__(**kwargs)
        self.monitor = monitor
        self.content_id = content_id
        self.sleep_interval = self.monitor['interval']
        self.fall = 0
        self.rise = 0

    def check_fall(self):
        self.fall += 1
        self.rise = 0

        if self.fall >= self.monitor['fall'] and self.content_id not in Monitor.status:
            logging.error('{}: {}: status fall'.format(self.name, self.monitor))
            Monitor.status.add(self.content_id)

    def check_rise(self):
        self.fall = 0
        self.rise += 1

        if self.rise >= self.monitor['rise'] and self.content_id in Monitor.status:
            logging.info('{}: {}: status rise'.format(self.name, self.monitor))
            Monitor.status.remove(self.content_id)

    def do_exec(self):
        return subprocess32.call(self.monitor['args'], timeout=self.monitor['timeout']) == 0

    def do_http(self):
        urllib2.urlopen(self.monitor['url'], timeout=self.monitor['timeout']).close()
        return True

    def do_icmp(self):
        try:
            return pyping.ping(self.monitor['ip'], timeout=self.monitor['timeout'] * 1000, count=1).ret_code == 0
        except SystemExit:
            raise PingError('unknown host: {}'.format(self.monitor['ip']))

    def do_tcp(self):
        socket.create_connection((self.monitor['ip'], self.monitor['port']), self.monitor['timeout']).close()
        return True

    def task(self):
        try:
            if getattr(self, 'do_' + self.monitor['type'])():
                logging.debug('{}: {}: return True'.format(self.name, self.monitor))
                self.check_rise()
            else:
                logging.debug('{}: {}: return False'.format(self.name, self.monitor))
                self.check_fall()
        except Exception as e:
            logging.debug('{}: {}: return Exception: {}: {}'.format(self.name, self.monitor, type(e).__name__, e))
            self.check_fall()


class Database(mysql.connector.MySQLConnection):

    Error = mysql.connector.Error

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.disconnect()

    def __init__(self):
        super(Database, self).__init__(**dict(PowerGSLB.config.items('mysql')))

    def execute(self, query, params=()):
        query = ' '.join(filter(bool, (line.strip() for line in query.splitlines())))

        if params:
            logging.debug('{}: "{}" % {}'.format(type(self).__name__, query, params))
        else:
            logging.debug('{}: "{}"'.format(type(self).__name__, query))

        cursor = self.cursor()
        cursor.execute(query, params)

        column_names = [description[0] for description in cursor.description]
        result = [dict(zip(column_names, row)) for row in cursor]
        cursor.close()

        return result

    def get_checks(self):
        query = """
            SELECT contents.id,
                   contents.content,
                   monitors.monitor
            FROM contents
            JOIN monitors ON contents.monitor_id = monitors.id
            WHERE monitors.monitor <> ''
        """

        return self.execute(query)

    def get_records(self, qname, qtype):
        if qtype == 'ANY':
            query = """
                SELECT records.name AS qname,
                       records.type AS qtype,
                       records.ttl,
                       records.persistence,
                       contents.id,
                       contents.content,
                       contents.fallback,
                       contents.weight
                FROM records
                JOIN records_contents ON records.id = records_contents.record_id
                JOIN contents ON records_contents.content_id = contents.id
                WHERE records.name = %s
                  AND records.disabled = 0
            """
            params = (qname,)
        else:
            query = """
                SELECT records.name AS qname,
                       records.type AS qtype,
                       records.ttl,
                       records.persistence,
                       contents.id,
                       contents.content,
                       contents.fallback,
                       contents.weight
                FROM records
                JOIN records_contents ON records.id = records_contents.record_id
                JOIN contents ON records_contents.content_id = contents.id
                WHERE records.name = %s
                  AND records.type = %s
                  AND records.disabled = 0
            """
            params = (qname, qtype)

        return self.execute(query, params)

    def get_status(self):
        query = """
            SELECT domains.domain,
                   records.name,
                   records.type,
                   records.ttl,
                   records.disabled,
                   records.persistence,
                   contents.id,
                   contents.content,
                   contents.fallback,
                   contents.weight,
                   monitors.description AS monitor
            FROM domains
            JOIN records ON domains.id = records.domain_id
            JOIN records_contents ON records.id = records_contents.record_id
            JOIN contents ON records_contents.content_id = contents.id
            JOIN monitors ON contents.monitor_id = monitors.id
        """

        return self.execute(query)


class HTTPRequestHandler(SimpleHTTPServer.SimpleHTTPRequestHandler, object):

    close_connection = 0
    protocol_version = 'HTTP/1.1'
    server_version = 'PowerGSLB/' + __version__
    rbufsize = -1
    wbufsize = -1

    def __init__(self, *args):
        self.database = None
        self.ipv4_prefix = PowerGSLB.config.get('persistence', 'ipv4_prefix')
        self.ipv6_prefix = PowerGSLB.config.get('persistence', 'ipv6_prefix')
        super(HTTPRequestHandler, self).__init__(*args)

    def do_GET(self):
        query = self.path.split('?', 1)[0]
        query = query.split('/')[1:]

        if not query:
            self.send_error(501)

        elif query[0] == 'admin':
            path = self.translate_path(self.path)

            if os.path.isdir(path) and not self.path.endswith('/'):
                self.send_response(301)
                self.send_header('Location', self.path + '/')
                self.send_header('Connection', 'close')
                self.end_headers()
            else:
                super(HTTPRequestHandler, self).do_GET()

        elif query[0] == 'dns':
            self.send_response(200)
            content = self.get_result(query[1:])
            self.send_header('Content-Type', 'text/javascript; charset=utf-8')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
            logging.debug('{}: {}'.format(type(self).__name__, content))

        elif query[0] == 'status':
            self.send_response(200)
            content = self.get_status()
            self.send_header('Content-Type', 'text/javascript; charset=utf-8')
            self.send_header('Content-Length', len(content))
            self.end_headers()
            self.wfile.write(content)
        else:
            self.send_error(404)

    def filter_records(self, qtype_records):
        records = []
        for qtype in qtype_records:

            fallback_records = {}
            live_records = {}

            for record in qtype_records[qtype]:
                if record['fallback']:
                    if record['weight'] not in fallback_records:
                        fallback_records[record['weight']] = []

                    fallback_records[record['weight']].append(record)

                if record['id'] not in Monitor.status:
                    if record['weight'] not in live_records:
                        live_records[record['weight']] = []

                    live_records[record['weight']].append(record)

            if live_records:
                filtered_records = live_records[max(live_records)]
            else:
                filtered_records = fallback_records[max(fallback_records)]

            if not filtered_records:
                continue

            if any(record['persistence'] for record in filtered_records):
                records.append(self.remote_ip_persistence(filtered_records))
            else:
                records.extend(filtered_records)

        return records

    def get_result(self, query):
        result = False

        if len(query) == 3 and query[0] == 'lookup':
            try:
                records = self.database.get_records(*query[1:])
            except Database.Error as e:
                logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
                self.close_connection = 1
            else:
                if records:
                    qtype_records = self.split_records(records)
                    filtered_records = self.filter_records(qtype_records)
                    result = self.strip_records(filtered_records)

        return json.dumps({'result': result}, separators=(',', ':'))

    def get_status(self):
        try:
            records = self.database.get_status()
        except Database.Error as e:
            logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
            status = {'status': 'error', 'message': e}
            self.close_connection = 1
        else:
            for record in records:
                if record['disabled'] or record['id'] in Monitor.status:
                    record['status'] = 'OFF'
                else:
                    record['status'] = 'ON'

                del record['id']

            status = {'status': 'success', 'total': len(records), 'records': records}

        return json.dumps(status, separators=(',', ':'))

    def handle(self):
        try:
            with Database() as self.database:
                while not self.close_connection:
                    self.handle_one_request()
        except Database.Error as e:
            logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))

    def remote_ip_persistence(self, records):
        ip_value = 0
        remote_ip = self.headers.get('X-Remotebackend-Real-Remote')

        if remote_ip is None:
            logging.error("{}: 'X-Remotebackend-Real-Remote' header missing".format(type(self).__name__))
        else:
            try:
                network = netaddr.IPNetwork(remote_ip)
            except netaddr.AddrFormatError as e:
                logging.error("{}: 'X-Remotebackend-Real-Remote' header invalid: {}: {}".format(
                        type(self).__name__, type(e).__name__, e))
            else:
                if network.version == 4:
                    ip_value = network.ip.value >> self.ipv4_prefix
                elif network.version == 6:
                    ip_value = network.ip.value >> self.ipv6_prefix

        return records[hash(ip_value) % len(records)]

    def split_records(self, records):
        qtype_records = {}
        for record in records:
            if record['qtype'] in ['MX', 'SRV']:
                content_split = record['content'].split()
                try:
                    record['priority'] = int(content_split[0])
                    record['content'] = ' '.join(content_split[1:])
                except (KeyError, ValueError) as e:
                    logging.error('{}: record id {} priority missing or invalid: {}: {}'.format(
                            type(self).__name__, record['id'], type(e).__name__, e))
                    continue

            if record['qtype'] not in qtype_records:
                qtype_records[record['qtype']] = []

            qtype_records[record['qtype']].append(record)

        return qtype_records

    @staticmethod
    def strip_records(records):
        result = []
        for record in records:
            if record['qtype'] in ['MX', 'SRV']:
                names = ['qname', 'qtype', 'content', 'ttl', 'priority']
                values = [record['qname'], record['qtype'], record['content'], record['ttl'], record['priority']]
            else:
                names = ['qname', 'qtype', 'content', 'ttl']
                values = [record['qname'], record['qtype'], record['content'], record['ttl']]

            result.append(dict(zip(names, values)))

        return result


class LockSet(set):

    def __init__(self, seq=()):
        super(LockSet, self).__init__(seq)
        self.__lock = threading.RLock()

    def add(self, elem):
        with self.__lock:
            return super(LockSet, self).add(elem)

    def remove(self, elem):
        with self.__lock:
            return super(LockSet, self).add(elem)


class Monitor(AbstractThread):

    check_params = {
        'exec': [('args', list), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'icmp': [('ip', str), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'http': [('url', str), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)],
        'tcp': [('ip', str), ('port', int), ('interval', int), ('timeout', int), ('fall', int), ('rise', int)]
    }

    status = LockSet()

    def __init__(self, **kwargs):
        super(Monitor, self).__init__(**kwargs)
        self.check_threads = []
        self.checks = []
        self.refresh_threads = False
        self.sleep_interval = PowerGSLB.config.get('monitor', 'update_interval')

    def clean_status(self):
        check_ids = set(check['id'] for check in self.checks)
        stale_ids = Monitor.status.difference(check_ids)

        if stale_ids:
            logging.debug('{}: clean status for records: {}'.format(
                    type(self).__name__, ', '.join(map(str, stale_ids))))
            Monitor.status.intersection_update(check_ids)

    def parse(self, check):
        parse_status = False
        try:
            check['monitor'] = dict(ast.literal_eval(check['monitor'] % check))
            parse_status = True
        except (SyntaxError, ValueError) as e:
            logging.error('{}: record id {}: check parsing error: {}: {}'.format(
                    type(self).__name__, check['id'], type(e).__name__, e))

        return parse_status

    def shutdown_check_threads(self):
        if not self.check_threads:
            logging.info('{}: check threads are not running'.format(type(self).__name__))
            return

        logging.debug('{}: shutdown threads: {}'.format(type(self).__name__, self.check_threads))

        alive_threads = []
        shutdown_timeout = 0

        for check_thread in self.check_threads:
            if check_thread.is_alive():
                check_thread.shutdown()
                alive_threads.append(check_thread)
                if check_thread.sleep_interval > shutdown_timeout:
                    shutdown_timeout = check_thread.sleep_interval

        shutdown_time = time.time()
        shutdown_timeout *= 2

        while alive_threads and time.time() - shutdown_time < shutdown_timeout:
            time.sleep(1)
            alive_threads = [alive_thread for alive_thread in alive_threads if alive_thread.is_alive()]

        self.check_threads = alive_threads

    def start_check_threads(self):
        if self.check_threads:
            logging.error('{}: check threads already running: {}'.format(type(self).__name__, self.check_threads))
            return

        check_threads = []
        for check in self.checks:
            check_thread = CheckThread(check['monitor'], check['id'], name='Check-{}'.format(check['id']))
            check_thread.start()
            check_threads.append(check_thread)

        logging.debug('{}: started threads: {}'.format(type(self).__name__, check_threads))

        self.check_threads = check_threads

    def task(self):
        self.update_checks()
        self.verify_check_threads()
        if self.refresh_threads:
            self.shutdown_check_threads()
            self.clean_status()
            self.start_check_threads()

    def update_checks(self):
        logging.info('{}: update checks from the database'.format(type(self).__name__))
        refresh_threads = False
        try:
            with Database() as database:
                raw_checks = database.get_checks()
        except Database.Error as e:
            logging.error('{}: {}: {}'.format(type(self).__name__, type(e).__name__, e))
        else:
            checks = [check for check in raw_checks if self.parse(check) and self.validate(check)]
            if self.checks != checks:
                logging.debug('{}: checks updated: {}'.format(type(self).__name__, checks))
                self.checks = checks
                refresh_threads = True

        self.refresh_threads = refresh_threads

    def validate(self, check):
        validate_status = False
        try:
            for param in self.check_params[check['monitor']['type']]:
                if type(check['monitor'][param[0]]) != param[1]:
                    logging.error("{}: record id {}: check parameter '{}' invalid".format(
                            type(self).__name__, check['id'], param[0]))
        except KeyError as e:
            logging.error("{}: record id {}: check parameter '{}' missing".format(
                    type(self).__name__, check['id'], e.message))
        else:
            if check['monitor']['timeout'] > check['monitor']['interval']:
                logging.warning("{}: record id {}: check 'timeout' is greater than 'interval': fixed".format(
                        type(self).__name__, check['id']))
                check['monitor']['timeout'] = check['monitor']['interval']

            validate_status = True

        return validate_status

    def verify_check_threads(self):
        if self.refresh_threads:
            return

        check_ids = set(check['id'] for check in self.checks)
        check_thread_ids = set(thread.content_id for thread in self.check_threads if thread.is_alive())

        if check_ids != check_thread_ids:
            running_thread_ids = check_thread_ids.difference(check_ids)
            stopped_thread_ids = check_ids.difference(check_thread_ids)

            if running_thread_ids:
                logging.error('{}: unexpectedly running threads: {}'.format(
                        type(self).__name__, ', '.join(map('Check-{}'.format, running_thread_ids))))

            if stopped_thread_ids:
                logging.error('{}: unexpectedly stopped threads: {}'.format(
                        type(self).__name__, ', '.join(map('Check-{}'.format, stopped_thread_ids))))

            self.refresh_threads = True


class PingError(Exception):
    pass


class Server(AbstractThread):

    def __init__(self, **kwargs):
        super(Server, self).__init__(**kwargs)
        self.address = PowerGSLB.config.get('server', 'address')
        self.port = PowerGSLB.config.get('server', 'port')
        self.root = PowerGSLB.config.get('server', 'root')

        os.chdir(self.root)

    def task(self):
        logging.info('{}: listening on {}:{}'.format(type(self).__name__, self.address, self.port))
        http_server = ThreadingHTTPServer((self.address, self.port), HTTPRequestHandler)
        http_server.daemon_threads = True
        http_server.serve_forever()


class Service(object):

    def __init__(self, service_threads):
        self.service_threads = service_threads
        self.sleep_interval = self.watchdog_interval()

    def start(self):
        for service_thread in self.service_threads:
            service_thread.start()

        if systemd.daemon.booted():
            systemd.daemon.notify('READY=1')

        while all(service_thread.is_alive() for service_thread in self.service_threads):
            if systemd.daemon.booted():
                systemd.daemon.notify('STATUS=Total threads: {}; Service threads: {}\nWATCHDOG=1'.format(
                        threading.active_count(), len(self.service_threads)))
            time.sleep(self.sleep_interval)

    @staticmethod
    def watchdog_interval(interval=1):
        if 'WATCHDOG_USEC' in os.environ:
            interval = min(interval, int(os.environ['WATCHDOG_USEC']) / 1000000 / 2)
        return interval


class SmartConfigParser(ConfigParser.RawConfigParser, object):

    def __init__(self, filenames, **kwargs):
        super(SmartConfigParser, self).__init__(**kwargs)
        self.read(filenames)

    def get(self, section, option):
        value = super(SmartConfigParser, self).get(section, option)
        try:
            value = ast.literal_eval(value)
        except (SyntaxError, ValueError):
            pass

        return value

    def items(self, section):
        smart_items = []
        for key, value in super(SmartConfigParser, self).items(section):
            try:
                value = ast.literal_eval(value)
            except (SyntaxError, ValueError):
                pass

            smart_items.append((key, value))

        return smart_items


class ThreadingHTTPServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass


class PowerGSLB(object):

    config = None

    @classmethod
    def main(cls):
        args_parser = argparse.ArgumentParser()
        args_parser.add_argument('-c', '--config', default='powergslb.conf')
        args = args_parser.parse_args()

        cls.config = SmartConfigParser(args.config)

        logging.basicConfig(format=cls.config.get('logging', 'format'),
                            level=logging.getLevelName(cls.config.get('logging', 'level')))

        service_threads = [Monitor(name='Monitor'), Server(name='Server')]
        service = Service(service_threads)
        service.start()


if __name__ == '__main__':
    PowerGSLB.main()
